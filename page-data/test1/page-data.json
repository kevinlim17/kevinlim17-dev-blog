{"componentChunkName":"component---src-templates-post-template-tsx","path":"/test1/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2 id=\"-architecture-pattern이란\" style=\"position:relative;\"><a href=\"#-architecture-pattern%EC%9D%B4%EB%9E%80\" aria-label=\" architecture pattern이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>→ Architecture Pattern이란</h2>\n<blockquote>\n<p>An <strong>architectural pattern</strong> is a general, reusable solution </br>\nto a commonly occurring problem in software architecture<br>\nwithin a given context.</p>\n</blockquote>\n<p>위키피디아에서는 아키텍처 패턴을 “주어진 컨텍스트 내에서, 소프트웨어 아키텍처에서 주로 발생하는 문제에 대한 일반적이고, 재사용 가능한 솔루션”이라고 정의합니다.\n여기서 <strong>소프트웨어 아키텍처에서 주로 발생하는 문제</strong>라 함은, 서비스를 구현하고 유지-보수의 단계에 이르기까지 개발자가 직면하는 모든 상황을 일컫는 말입니다.\n필자는 그러한 케이스들을 ‘특정한 형식을 취하여’ 쉽게 풀어나갈 수 있도록 하는 <strong>약속의 소프트웨어적 구현 방식</strong>을 ‘아키텍처 패턴’이라고 생각합니다.</p>\n<hr>\n<h2 id=\"️-architecture-pattern의-종류\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-architecture-pattern%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"️ architecture pattern의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🗂️ Architecture Pattern의 종류</h2>\n<p>이 단락에서는 순서대로 <strong>MVC, MVP, MVVM</strong> 패턴으로 구현된 애플리케이션의 기본적인 Data Flow에 대해 다룹니다.</p>\n<h3 id=\"0️⃣-기본-용어-정리-frontend-기준\" style=\"position:relative;\"><a href=\"#0%EF%B8%8F%E2%83%A3-%EA%B8%B0%EB%B3%B8-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC-frontend-%EA%B8%B0%EC%A4%80\" aria-label=\"0️⃣ 기본 용어 정리 frontend 기준 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0️⃣ 기본 용어 정리 (Frontend 기준)</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">용어</th>\n<th align=\"left\">의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><strong>View</strong></td>\n<td align=\"left\">사용자가 <strong>화면에서 보는 것들</strong>에 대한 구조, 배치, 그리고 외관.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Model</strong></td>\n<td align=\"left\"><strong>Data와 Data를 가져오는 Logic</strong>을 통틀어 이르는 말.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Controller</strong></td>\n<td align=\"left\">Model에 명령을 보내 그 상태를 변경 &#x26; View에 명령을 보내 Model의 표시 방법 변경.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Presenter</strong></td>\n<td align=\"left\">View가 요청하는 Data를 Model로부터 가져와, 이를 가공하여 View에 전달.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>ViewModel</strong></td>\n<td align=\"left\">View의 <strong>추상화된 형태</strong>(Abstraction). View에 보여지는 데이터와 명령들을 가지고 있음.</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"1️⃣-model-view-controller\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-model-view-controller\" aria-label=\"1️⃣ model view controller permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ Model-View-Controller</h3>\n<p align=\"left\">\n    <img src=\"https://github.com/kevinlim17/dcom-tech-interview/blob/master/Frontend/Android/images/mvvm-design-pattern-01.png?raw=true\" width=\"80%\">\n</p>\n<p><u><strong>특징: Model과 View 사이의 의존성이 강함</strong></u></p>\n<ol>\n<li>Controller로 사용자의 입력이 들어옵니다.</li>\n<li>Controller는 Model의 데이터를 업데이트하거나, 사용자가 요청한 데이터를 불러오고,</li>\n<li>Model은 해당 데이터를 보여줄 View를 선택해서 화면에 보여주게 됩니다.</li>\n</ol>\n<hr>\n<h3 id=\"2️⃣-model-view-presenter\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-model-view-presenter\" aria-label=\"2️⃣ model view presenter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ Model-View-Presenter</h3>\n<p align=\"left\">\n    <img src=\"https://github.com/kevinlim17/dcom-tech-interview/blob/master/Frontend/Android/images/mvvm-design-pattern-02.png?raw=true\" width=\"80%\">\n</p>\n<p><u><strong>특징: Presenter와 View 사이의 의존성이 강함 (1:1로 대응.)</strong></u></p>\n<ol>\n<li>View를 통해 사용자의 특정한 입력이 들어옵니다.</li>\n<li>View는 Presenter에 작업(데이터 업데이트 및 필요한 데이터 가져오기) 요청을 합니다.</li>\n<li>Presenter가 필요한 데이터를 Model에 요청합니다.</li>\n<li>Model은 Presenter가 요청한 데이터를 응답으로 내보냅니다.</li>\n<li>Presenter는 View에 데이터를 내보냅니다.</li>\n<li>View는 Presenter로부터 받은 데이터로 각각의 View Component들이 구성됩니다.</li>\n</ol>\n<hr>\n<h3 id=\"3️⃣-model-view-viewmodel\" style=\"position:relative;\"><a href=\"#3%EF%B8%8F%E2%83%A3-model-view-viewmodel\" aria-label=\"3️⃣ model view viewmodel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3️⃣ Model-View-ViewModel</h3>\n<p align=\"left\">\n    <img src=\"https://github.com/kevinlim17/dcom-tech-interview/blob/master/Frontend/Android/images/mvvm-design-pattern-03.png?raw=true\" width=\"80%\">\n</p>\n<p><u><strong>특징: View와 ViewModel이 n:1로 대응 → ViewModel Class의 재활용성 ⬆️</strong></u></p>\n<ol>\n<li>View를 통해 사용자의 입력이 들어오면, Command Pattern으로 ViewModel에 특정 Action을 전달합니다.</li>\n<li>ViewModel은 필요한 데이터를 Model에 요청합니다.</li>\n<li>Model은 ViewModel에 요청한 데이터를 넘겨줍니다.</li>\n<li>ViewModel은 응답 받은 데이터를 가공해서 <strong>View의 상태(State)를 Hold</strong>합니다.</li>\n<li>View는 ViewModel과의 <strong>Data Binding</strong>을 통해 자동으로 갱신됩니다.\n(이를 View가 ViewModel이 가진 Data를 <strong>Observe</strong>, 즉 관찰한다고 표현합니다.)</li>\n</ol>\n<hr>\n<h2 id=\"-mvvm-pattern을-권장하는-이유\" style=\"position:relative;\"><a href=\"#-mvvm-pattern%EC%9D%84-%EA%B6%8C%EC%9E%A5%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\" mvvm pattern을 권장하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🏁 MVVM Pattern을 권장하는 이유</h2>\n<h3 id=\"1️⃣-seperation-of-concerns-관심사-분리\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-seperation-of-concerns-%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC\" aria-label=\"1️⃣ seperation of concerns 관심사 분리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ Seperation of Concerns: 관심사 분리</h3>\n<p align=\"left\">\n    <img src=\"https://github.com/kevinlim17/dcom-tech-interview/blob/master/Frontend/Android/images/mvvm-design-pattern-04.png?raw=true\" width=\"50%\">\n</p>\n<ul>\n<li>\n<p>Android에서는(다른 Frontend 개발과 비슷하게) 애플리케이션의 시스템을 크게 세 가지 계층(layer)으로 구분하여 설계합니다. </br> <strong>UI Layer</strong>, <strong>Domain Layer</strong>(선택사항), <strong>Data Layer</strong>가 바로 그것입니다.</p>\n</li>\n<li>\n<p>어떤 아키텍처 패턴을 사용하든지 간에, 세 Layer에 각각의 역할을 적절하게 부여하여, </br> 다른 모든 SW 개발과 마찬가지로 <a href=\"https://en.wikipedia.org/wiki/Separation_of_concerns\" target=\"_blank\" rel=\"nofollow\">관심사 분리 원칙</a>을 충실히 이행해야 합니다.</p>\n</li>\n<li>\n<p>주로, Android Native 개발에서 위 원칙을 위반하는 경우는 <strong><code class=\"language-text\">Activity</code>나 <code class=\"language-text\">Fragment</code>에 모든 코드를 작성하는 실수</strong>로 인해 발생합니다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">Activity</code>나 <code class=\"language-text\">Fragment</code>와 같은 UI-Based Class는 User Interface,\n그리고 User와의 상호작용(ex. 버튼 클릭 등)을 처리하는 로직만을 포함해야 합니다.</p>\n</li>\n<li>\n<p>이러한 Class를 최대한 가볍게 유지하는 것이 Component Lifecycle와 관련된 문제를 피하고,\n테스트 유용성 및 유지/보수의 용이성을 높이는 데 도움이 됩니다.</p>\n</li>\n</ul>\n<h3 id=\"️-uwhy-not-mvc--비대해지는-ui-controlleru\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-uwhy-not-mvc--%EB%B9%84%EB%8C%80%ED%95%B4%EC%A7%80%EB%8A%94-ui-controlleru\" aria-label=\"️ uwhy not mvc  비대해지는 ui controlleru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>☑️ <u>Why not MVC : 비대해지는 UI Controller</u></h3>\n<p align=\"left\">\n    <img src=\"https://github.com/kevinlim17/dcom-tech-interview/blob/master/Frontend/Android/images/mvvm-design-pattern-05.png?raw=true\" width=\"80%\">\n</p>\n<ul>\n<li>안드로이드에 MVC 아키텍처 패턴을 적용하는 것이 어려운 이유는, 위에서 언급한 <strong>관심사 분리 원칙을 정면으로 위배</strong>하는 행위이기 때문입니다.</li>\n<li>Android Native에서 Controller에 해당하는 역할을 수행하는 Class가 바로 <code class=\"language-text\">Activity</code>와 <code class=\"language-text\">Fragment</code>인데,\n이 둘은 UI-based Class로서의 기능도 해야 합니다. <code class=\"language-text\">.xml</code> 파일은 그저 UI Component를 보여주는 역할만 수행할 뿐 입니다.</li>\n<li>MVC로 프로젝트를 구성하게 되면, <code class=\"language-text\">Activity</code>와 <code class=\"language-text\">Fragment</code>가 User와의 상호작용은 물론, </br>\nModel과의 상호작용(데이터 요청 및 수정)도 동시에 담당하게 되므로, 관심사 분리 원칙에서 언급한 <strong>실수</strong>가 일어나게 됩니다.</li>\n<li>여러 기능을 구현할수록, Controller에 해당하는 코드의 양이 비대해지며, 이는 유지/보수를 어렵게 합니다.</li>\n</ul>\n<hr>\n<h3 id=\"2️⃣-unidirectional-data-flow-단방향-데이터-흐름\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-unidirectional-data-flow-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84\" aria-label=\"2️⃣ unidirectional data flow 단방향 데이터 흐름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ Unidirectional Data Flow: 단방향 데이터 흐름</h3>\n<p align=\"left\">\n    <img src=\"https://github.com/kevinlim17/dcom-tech-interview/blob/master/Frontend/Android/images/mvvm-design-pattern-06.png?raw=true\" width=\"50%\">\n</p>\n<ul>\n<li>Android Native에서, 단방향 데이터 흐름 패턴(이하 <strong>UDF 패턴</strong>)을 충족한다는 것은, </br>\n1️⃣ <u><strong>상태(State or Data)는 Data Layer에서 UI Layer로 흐른다는 것</strong></u>, </br>\n2️⃣ <u><strong>데이터 흐름을 수정하게 되는 이벤트(User Action)는 UI Layer에서 Data Layer 방향으로 흐른다는 것을</strong></u> 의미합니다.</li>\n<li>이는 데이터 관리의 안정성을 강화하며, 오류가 발생할 가능성을 크게 낮춥니다.</li>\n<li>Android에서는 이러한 흐름을 다음과 같은 구성으로 구현합니다. (Event 흐름 기준)\n<ul>\n<li>UI Layer : <strong>UI Elements (View or Jetpack Compose)</strong> -> <strong>State Holder(ViewModel Class)</strong> -></li>\n<li>Data Layer : -> <strong>Repositories</strong> -><strong>Data Source(A Network Source, a File, or a local DB)</strong></li>\n</ul>\n</li>\n<li>위에서 State Holder의 역할은 MVP 패턴에서는 <u>Presenter</u>가, MVVM 패턴에서는 <u>ViewModel</u>이 담당합니다.</li>\n</ul>\n<h3 id=\"️-ustate-holder--viewmodel-vs-presenteru\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-ustate-holder--viewmodel-vs-presenteru\" aria-label=\"️ ustate holder  viewmodel vs presenteru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>☑️ <u>State Holder : ViewModel vs. Presenter</u></h3>\n<h4 id=\"공통점\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%ED%86%B5%EC%A0%90\" aria-label=\"공통점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공통점</h4>\n<ul>\n<li>Android Native에서 <strong>MVP와 MVVM 패턴의 공통점은 <code class=\"language-text\">Activity</code>와 <code class=\"language-text\">Fragment</code>가 User와의 상호작용만을 담당한다는 것</strong>입니다.</li>\n<li>두 아키텍처 패턴은 관심사 분리 원칙에 온전히 부합하며, 단방향 데이터 흐름 패턴을 가집니다.</li>\n<li>위에서 언급하지 않은 내용이지만, MVC에서는 View가 사실상 Controller와 결합된 형태라, 유닛 테스트 구성이 번거롭습니다.\n하지만 MVP의 경우, State Holder가 특정 View와 결합되지 않기 때문에, 가상 뷰를 구현하는 방식으로 유닛 테스트을 진행할 수 있습니다.</li>\n</ul>\n<h4 id=\"차이점\" style=\"position:relative;\"><a href=\"#%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차이점</h4>\n<ul>\n<li>\n<p>그러나 <strong>MVVM의 ViewModel은 MVP의 Presenter와 달리, View에 대한 의존성을 전혀 가지고 있지 않습니다.</strong></p>\n</li>\n<li>\n<p><strong>Data Binding과 (ViewModel에 존재하는) Observable(관찰 가능한) 변수</strong>는 보다 애플리케이션의 반응 속도를 높여줍니다.</p>\n</li>\n<li>\n<p>MVP에서처럼 가상 뷰를 만드는 방식이 아니라, 그저 Observable 변수가 제대로 설정되었는지 확인하는 것 만으로 유닛 테스트가 가능해집니다.</p>\n</li>\n<li>\n<p>Android의 AAC(Android Architecture Component, Jetpack에 포함된 라이브러리) ViewModel은\n여러 Fragment가 <strong>공통된 데이터를 각자가 담당한 View에 Binding할 수 있도록 구현</strong>되어 있으므로 (데이터 공유 역할),\nPresenter에 비해 재활용성이 높다는 점도 큰 장점입니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"-references\" style=\"position:relative;\"><a href=\"#-references\" aria-label=\" references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧭 References</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Architectural_pattern\" target=\"_blank\" rel=\"nofollow\">영문판 위키피디아 - Architectural Pattern</a></li>\n<li><a href=\"https://developer.android.com/jetpack/guide?hl=en\" target=\"_blank\" rel=\"nofollow\">Guide to App Architecture - Android Developer (4,6번 이미지 출처)</a></li>\n<li><a href=\"https://academy.realm.io/kr/posts/eric-maxwell-mvc-mvp-and-mvvm-on-android/\" target=\"_blank\" rel=\"nofollow\">안드로이드의 MVC, MVP, MVVM 종합 안내서</a></li>\n</ul>\n<hr>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#-architecture-pattern%EC%9D%B4%EB%9E%80\">→ Architecture Pattern이란</a></p>\n</li>\n<li>\n<p><a href=\"#%EF%B8%8F-architecture-pattern%EC%9D%98-%EC%A2%85%EB%A5%98\">🗂️ Architecture Pattern의 종류</a></p>\n<ul>\n<li><a href=\"#0%EF%B8%8F%E2%83%A3-%EA%B8%B0%EB%B3%B8-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC-frontend-%EA%B8%B0%EC%A4%80\">0️⃣ 기본 용어 정리 (Frontend 기준)</a></li>\n<li><a href=\"#1%EF%B8%8F%E2%83%A3-model-view-controller\">1️⃣ Model-View-Controller</a></li>\n<li><a href=\"#2%EF%B8%8F%E2%83%A3-model-view-presenter\">2️⃣ Model-View-Presenter</a></li>\n<li><a href=\"#3%EF%B8%8F%E2%83%A3-model-view-viewmodel\">3️⃣ Model-View-ViewModel</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-mvvm-pattern%EC%9D%84-%EA%B6%8C%EC%9E%A5%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">🏁 MVVM Pattern을 권장하는 이유</a></p>\n<ul>\n<li>\n<p><a href=\"#1%EF%B8%8F%E2%83%A3-seperation-of-concerns-%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC\">1️⃣ Seperation of Concerns: 관심사 분리</a></p>\n</li>\n<li>\n<p><a href=\"#%EF%B8%8F-uwhy-not-mvc--%EB%B9%84%EB%8C%80%ED%95%B4%EC%A7%80%EB%8A%94-ui-controlleru\">☑️ <u>Why not MVC : 비대해지는 UI Controller</u></a></p>\n</li>\n<li>\n<p><a href=\"#2%EF%B8%8F%E2%83%A3-unidirectional-data-flow-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84\">2️⃣ Unidirectional Data Flow: 단방향 데이터 흐름</a></p>\n</li>\n<li>\n<p><a href=\"#%EF%B8%8F-ustate-holder--viewmodel-vs-presenteru\">☑️ <u>State Holder : ViewModel vs. Presenter</u></a></p>\n<ul>\n<li><a href=\"#%EA%B3%B5%ED%86%B5%EC%A0%90\">공통점</a></li>\n<li><a href=\"#%EC%B0%A8%EC%9D%B4%EC%A0%90\">차이점</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-references\">🧭 References</a></p>\n</li>\n</ul>","frontmatter":{"title":"Android에서 MVVM 패턴이 중요한 이유","summary":"수많은 아키텍처 패턴 중 그대 단 하나","date":"2023.03.24","categories":["Android","Architecture"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACcklEQVR42m2MSU+TURSG79KVC8XEhULEIRE0hqACYogDhgiIUapFrIlDVBJXYMSoqEsZSwcosSv1Fxg1cURNFBSDE0qZagsFsS1R2q8ItbQ85rufIKCLJ+85533uFU0jzTT4H9Pof0LDPKz+x5J63wOMvgfU+x7+46iob83+Rwz9+oFY01lOsuMiyY4LMyTJvEie08huZy25zjp0Liv5X4yyS5rlqqzvukT851KaFQcir6+efBWnScsZTBhcdg67r1MycJPT/Tc44rbPczSvwGkmu7ea9p9uRJQwESaYZILorFQJMyb3j54uRid/EGH8v15EZhiYQrzpi/KqO0pLV5QXjigvHVq+6IzS2h2jpSuG/Y6TZx1hWrun5H3G69TydU+MVz1RQhNTiIyKAFuvBNlfp1BkDqEzKhw0KRwyh8i9psh7sXWcvTWK7PSmkOzk3aL5WVeDpJwP8LI7gki/FGBLRYCC6iAGq/ooyIkmhcMWhT1VQY7aFE7Zx+RssKhziCKTQrFZ4ZhN4YAxSOblACnlo7SoH34ahI8e+DAAb93wrh/a3dqs3tTubtt32pwxOau9itqr3vt+6PBo3lgYhH/Ei9f3FZ9/eA7D3kGGvg0y7B3i3tNmXAMuvP6vcp/vev/k5GQEsXBjDnEZ+SzOyNNI1zJxl56VOUUyl28vlCTs1BG/Q8eiP840SzL3sGDDDu49b0WIpesQq9IQiZvmsCJbR2ZxCWn6k6zK0ZNaeJwswxmWbduHSEhFrNz811+djohby63b9xHna22cq2mkvKZR5jRnq6yUVVopq7JytrpB3lRX3c/Nc8trbZRWWuh1e/gNe5u9tlnRzE4AAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/9824ffd239b76bc6b1d6d13cec417d1e/40e1f/test1.png","srcSet":"/static/9824ffd239b76bc6b1d6d13cec417d1e/e00b6/test1.png 431w,\n/static/9824ffd239b76bc6b1d6d13cec417d1e/53dcb/test1.png 863w,\n/static/9824ffd239b76bc6b1d6d13cec417d1e/40e1f/test1.png 1725w","sizes":"(min-width: 1725px) 1725px, 100vw"},"sources":[{"srcSet":"/static/9824ffd239b76bc6b1d6d13cec417d1e/19c1b/test1.webp 431w,\n/static/9824ffd239b76bc6b1d6d13cec417d1e/e7a57/test1.webp 863w,\n/static/9824ffd239b76bc6b1d6d13cec417d1e/eaee2/test1.webp 1725w","type":"image/webp","sizes":"(min-width: 1725px) 1725px, 100vw"}]},"width":1725,"height":1005}},"publicURL":"/static/9824ffd239b76bc6b1d6d13cec417d1e/test1.png"}}}}]}},"pageContext":{"slug":"/test1/"}},"staticQueryHashes":[],"slicesMap":{}}